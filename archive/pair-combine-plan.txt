Pair Combiner Feature: Statistical Pair Analysis Tool
Overview
Add a new "Pair Combiner" menu/tab to analyze the relationship between two trading pairs, identifying opportunities through advanced statistical methods:

Copula-Based Dependence - Measures non-linear tail dependencies
Wavelet Signal Decomposition - Multi-scale trend/noise separation
Transfer Entropy - Information flow direction between pairs
User Review Required
IMPORTANT

Data Requirements: Fetching two pairs simultaneously requires handling twice the API calls. Need to confirm if the existing Binance/TwelveData rate limits can support this.

IMPORTANT

Analysis Complexity: Should all three analysis methods (copula, wavelets, transfer entropy) be implemented in Phase 1, or should we prioritize one method first?

NOTE

Performance Consideration: Wavelet decomposition and transfer entropy can be computationally expensive for large datasets (30k+ bars). Should we add a recommended data limit warning in the UI?

Proposed Changes
State & Types
[MODIFY]
state.ts
Add pair combiner state management:

// New state fields
public pairCombinerEnabled = false;
public secondarySymbol: string | null = null;
public secondaryInterval: string | null = null;
public secondaryOhlcvData: OHLCVData[] = [];
public pairAnalysisResults: PairAnalysisResults | null = null;
HTML/UI Components
[NEW]
tab-paircombiner.html
New tab content with:

Secondary pair selector (reuses symbol search pattern from
header.html
)
Analysis method checkboxes (copula, wavelets, transfer entropy)
"Analyze" button to trigger computation
Results display panel with metrics
[MODIFY]
strategy-panel-shell.html
Add new tab button in "Analysis" group:

<button class="panel-tab" data-tab="paircombiner" title="Pair Combiner Analysis">
    <svg><!-- Pair icon --></svg>
    <span>Pairs</span>
</button>
Core Analysis Modules
[NEW]
lib/pairCombiner/
New directory containing analysis engines:

[NEW]
copulaDependence.ts
Measures non-linear dependence between two return series:

interface CopulaResult {
    kendallTau: number;        // Rank correlation
    tailDependence: {
        upper: number;         // Joint extreme gains
        lower: number;         // Joint extreme losses
    };
    copulaType: 'gaussian' | 'clayton' | 'gumbel'; // Best fit
    opportunityScore: number;  // 0-100 divergence opportunity
}
export function calculateCopulaDependence(
    returns1: number[],
    returns2: number[],
    windowSize?: number
): CopulaResult;
Key Features:

Empirical copula construction from pseudo-observations
Kendall's tau calculation for rank correlation
Tail dependence coefficients (upper/lower)
Rolling window analysis for dynamic dependence
[NEW]
waveletDecomposition.ts
Decomposes price spread into multi-scale components:

interface WaveletResult {
    levels: WaveletLevel[];    // Decomposition levels
    dominantCycle: number;     // Primary cycle length in bars
    noiseRatio: number;        // Noise-to-signal ratio
    smoothedSpread: number[];  // Denoised spread series
    spreadZScore: number;      // Current normalized position
}
interface WaveletLevel {
    scale: number;             // Time scale (bars)
    detail: number[];          // Detail coefficients
    approximation: number[];   // Smoothed component
    energy: number;            // % of total signal energy
}
export function waveletDecompose(
    spread: number[],
    waveletType?: 'haar' | 'db4' | 'coif2',
    maxLevels?: number
): WaveletResult;
Key Features:

Haar wavelet (fast) or Daubechies-4 (smoother)
Multi-resolution analysis (MRA)
Cycle detection for mean-reversion timing
Denoised spread for cleaner signals
[NEW]
transferEntropy.ts
Measures directional information flow:

interface TransferEntropyResult {
    te_1_to_2: number;         // Info flow: pair1 → pair2
    te_2_to_1: number;         // Info flow: pair2 → pair1
    netFlow: number;           // Net direction (-1 to 1)
    leadingAsset: 'primary' | 'secondary' | 'neutral';
    lagBars: number;           // Optimal lead/lag
    significance: number;      // Statistical confidence
}
export function calculateTransferEntropy(
    returns1: number[],
    returns2: number[],
    historyLength?: number,
    bins?: number
): TransferEntropyResult;
Key Features:

Binned probability estimation (discretization)
Conditional entropy calculation
Lead-lag detection for alpha generation
Bootstrap significance testing
[NEW]
pairDataManager.ts
Handles synchronized dual-pair data:

interface AlignedPairData {
    primary: OHLCVData[];
    secondary: OHLCVData[];
    spread: number[];          // log(P1) - log(P2)
    ratio: number[];           // P1 / P2
    alignedTimestamps: Time[];
}
export async function fetchAndAlignPairs(
    primary: { symbol: string; interval: string },
    secondary: { symbol: string; interval: string }
): Promise<AlignedPairData>;
[NEW]
types.ts
Shared type definitions for pair analysis.

[NEW]
index.ts
Module barrel export.

Manager / Integration
[NEW]
pairCombinerManager.ts
Main orchestrator class:

class PairCombinerManager {
    init(): void;                    // Setup event listeners
    loadSecondaryPair(symbol: string, interval?: string): Promise<void>;
    runAnalysis(methods: AnalysisMethod[]): Promise<void>;
    displayResults(results: PairAnalysisResults): void;
    clearSecondaryPair(): void;
}
Chart Visualization
[MODIFY]
chartManager.ts
Add methods for pair overlay visualization:

// New methods
addSecondaryPairOverlay(data: OHLCVData[]): void;
removeSecondaryPairOverlay(): void;
displaySpreadChart(spread: number[], timestamps: Time[]): void;
displayCorrelationBand(upper: number[], lower: number[]): void;
Styling
[NEW]
pair-combiner.css
Styling for:

Pair selector components
Analysis results cards
Metric visualizations
Loading/progress states
Architecture Diagram
Visualization
Analysis Engines
Data Layer
Orchestration
State Management
UI Layer
Pair Combiner Tab
Secondary Pair Selector
Analysis Controls
state.ts
pairCombinerManager.ts
pairDataManager.ts
dataManager.ts
copulaDependence.ts
waveletDecomposition.ts
transferEntropy.ts
chartManager.ts
Verification Plan
Automated Tests
No existing automated tests specifically for pair analysis. Will add:

[NEW]
pairCombiner.spec.ts
Unit tests for analysis functions with known input/output pairs:

npx vitest run pairCombiner.spec.ts
Test cases:

Copula: Verify known correlation scenarios
Wavelets: Test decomposition energy preservation
Transfer Entropy: Confirm asymmetry detection
Manual Verification
Pair Selection Test

Open application: npm run dev
Navigate to Strategy Panel → Pairs tab
Load primary: BTCUSDT (1D)
Select secondary: ETHUSDT (1D)
Verify both pairs load without errors
Analysis Execution

Enable all three analysis methods
Click "Analyze"
Verify results panel shows metrics for each method
Check console for any calculation errors
Chart Overlay

Confirm secondary pair appears as overlay line
Verify spread chart displays below main chart
Test zoom/pan synchronization
Cross-Provider Test

Primary: BTCUSDT (Binance crypto)
Secondary: AAPL (TwelveData stock)
Verify alignment handles different timestamps gracefully
Implementation Order
Phase	Component	Priority	Estimated Effort
1	State & Types	High	Small
2	Tab UI (basic)	High	Medium
3	pairDataManager	High	Medium
4	copulaDependence	Medium	Medium
5	waveletDecomposition	Medium	Large
6	transferEntropy	Medium	Large
7	Chart visualization	Low	Medium
8	Styling polish	Low	Small
Open Questions for User
Should the secondary pair always match the primary's timeframe, or allow independent intervals?
Preferred method for displaying spread: separate sub-chart or overlay histogram?
Any specific copula models preferred beyond Gaussian/Clayton/Gumbel?
