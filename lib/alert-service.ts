/**
 * Alert Service - thin API client for the Cloudflare Worker alert system.
 * Worker URL is stored in localStorage under 'alert_worker_url'.
 */

import {
    buildStreamId,
    parseConfigNameFromStreamId,
    parseTwoHourParityFromStreamId,
} from "./alert-stream-id";

const WORKER_URL_KEY = 'alert_worker_url';
export type AlertTwoHourCloseParity = 'odd' | 'even';

// Types

export interface AlertSubscription {
    id: number;
    stream_id: string;
    enabled: number;
    symbol: string;
    interval: string;
    strategy_key: string;
    strategy_params_json: string;
    backtest_settings_json: string;
    freshness_bars: number;
    notify_telegram: number;
    notify_exit: number;
    candle_limit: number;
    last_processed_closed_candle_time: number;
    last_run_at: string | null;
    last_status: string | null;
    created_at: string;
    updated_at: string;
}

export interface AlertSubscriptionUpsert {
    streamId?: string;
    symbol?: string;
    interval?: string;
    strategyKey?: string;
    configName?: string;
    strategyParams?: Record<string, number>;
    backtestSettings?: unknown;
    freshnessBars?: number;
    notifyTelegram?: boolean;
    notifyExit?: boolean;
    enabled?: boolean;
    candleLimit?: number;
}

export interface AlertSignalRecord {
    id: number;
    stream_id: string;
    symbol: string;
    interval: string;
    strategy_key: string;
    direction: 'long' | 'short';
    signal_time: number;
    signal_price: number;
    signal_reason: string | null;
    payload_json: string;
    created_at: string;
}

export interface RunNowResult {
    streamId: string;
    status: string;
    closedCandleTimeSec?: number;
    result?: Record<string, unknown>;
}

/**
 * Build deterministic stream id. Keeps legacy format when no configName is provided.
 */
export function buildAlertStreamId(
    symbol: string,
    interval: string,
    strategyKey: string,
    configName?: string,
    twoHourCloseParity?: AlertTwoHourCloseParity
): string {
    return buildStreamId(symbol, interval, strategyKey, configName, twoHourCloseParity);
}

/**
 * Parse optional configuration name from stream id generated by buildAlertStreamId.
 */
export function parseAlertConfigNameFromStreamId(streamId: string): string | null {
    return parseConfigNameFromStreamId(streamId);
}

export function parseAlertTwoHourParityFromStreamId(streamId: string): AlertTwoHourCloseParity | null {
    return parseTwoHourParityFromStreamId(streamId);
}

// Helpers

function getWorkerUrl(): string {
    return localStorage.getItem(WORKER_URL_KEY) ?? '';
}

function setWorkerUrl(url: string): void {
    localStorage.setItem(WORKER_URL_KEY, url.replace(/\/+$/, ''));
}

function requireUrl(): string {
    const url = getWorkerUrl();
    if (!url) throw new Error('Worker URL not configured. Set it in the Alerts tab.');
    return url;
}

function truncateText(value: string, maxLen = 320): string {
    const trimmed = value.trim();
    if (trimmed.length <= maxLen) return trimmed;
    return `${trimmed.slice(0, Math.max(0, maxLen - 3))}...`;
}

function extractErrorMessage(body: unknown): string | null {
    if (!body || typeof body !== 'object') return null;
    const message = (body as Record<string, unknown>).error;
    return typeof message === 'string' && message.trim() ? message.trim() : null;
}

async function readApiBody(res: Response): Promise<{ json: unknown | null; text: string | null }> {
    const contentType = (res.headers.get('content-type') ?? '').toLowerCase();

    if (contentType.includes('application/json')) {
        try {
            return { json: await res.json(), text: null };
        } catch {
            return { json: null, text: null };
        }
    }

    try {
        const text = await res.text();
        if (!text.trim()) return { json: null, text: null };
        try {
            return { json: JSON.parse(text), text };
        } catch {
            return { json: null, text };
        }
    } catch {
        return { json: null, text: null };
    }
}

async function apiFetch<T>(path: string, options?: RequestInit): Promise<T> {
    const base = requireUrl();
    const res = await fetch(`${base}${path}`, {
        ...options,
        headers: { 'content-type': 'application/json', ...(options?.headers ?? {}) },
    });
    const body = await readApiBody(res);

    if (!res.ok) {
        const message = extractErrorMessage(body.json)
            ?? (body.text ? truncateText(body.text) : null)
            ?? `HTTP ${res.status}`;
        throw new Error(message);
    }

    if (body.json !== null) return body.json as T;
    throw new Error(`Unexpected non-JSON response (HTTP ${res.status}).`);
}

// Public API

export const alertService = {
    getWorkerUrl,
    setWorkerUrl,

    /** Test worker connectivity */
    async healthCheck(): Promise<{ ok: boolean; error?: string }> {
        try {
            const base = requireUrl();
            const res = await fetch(`${base}/health`);
            const body = await readApiBody(res);
            if (!res.ok) {
                return {
                    ok: false,
                    error: extractErrorMessage(body.json)
                        ?? (body.text ? truncateText(body.text) : `HTTP ${res.status}`),
                };
            }
            const json = body.json as Record<string, unknown> | null;
            return { ok: !!json?.ok };
        } catch (err) {
            return { ok: false, error: err instanceof Error ? err.message : String(err) };
        }
    },

    /** List all subscriptions */
    async listSubscriptions(): Promise<AlertSubscription[]> {
        const data = await apiFetch<{ ok: boolean; items: AlertSubscription[] }>('/api/subscriptions');
        return data.items ?? [];
    },

    /** Create or update a subscription */
    async upsertSubscription(payload: AlertSubscriptionUpsert): Promise<{
        ok: boolean;
        streamId: string;
        subscription: AlertSubscription;
    }> {
        return apiFetch('/api/subscriptions/upsert', {
            method: 'POST',
            body: JSON.stringify(payload),
        });
    },

    /** Disable a subscription (soft-delete) */
    async disableSubscription(streamId: string): Promise<void> {
        try {
            await apiFetch('/api/subscriptions/delete', {
                method: 'POST',
                body: JSON.stringify({ streamId }),
            });
        } catch {
            // Backward compatibility for workers that do not expose /delete yet.
            await apiFetch('/api/subscriptions/upsert', {
                method: 'POST',
                body: JSON.stringify({ streamId, enabled: false }),
            });
        }
    },

    /** Trigger immediate evaluation for a subscription */
    async runNow(streamId: string, force = false): Promise<RunNowResult> {
        const data = await apiFetch<{ ok: boolean; run?: RunNowResult } & Partial<RunNowResult>>('/api/subscriptions/run-now', {
            method: 'POST',
            body: JSON.stringify({ streamId, force }),
        });

        return data.run ?? {
            streamId: data.streamId ?? streamId,
            status: data.status ?? 'unknown',
            closedCandleTimeSec: data.closedCandleTimeSec,
            result: data.result,
        };
    },

    /** Get signal history for a stream */
    async getSignalHistory(streamId: string, limit = 20): Promise<AlertSignalRecord[]> {
        const data = await apiFetch<{ ok: boolean; signals?: AlertSignalRecord[]; items?: AlertSignalRecord[] }>(
            `/api/stream/signals?streamId=${encodeURIComponent(streamId)}&limit=${limit}`
        );
        return data.items ?? data.signals ?? [];
    },
};
